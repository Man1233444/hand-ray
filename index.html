<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Predictive Hand Ray 3D</title>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: black;
  overflow: hidden;
}

video, canvas {
  position: absolute;
  width: 100%;
  height: 100%;
  object-fit: cover;
}

#start {
  position: fixed;
  inset: 0;
  background: black;
  color: white;
  font-size: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 999;
  cursor: pointer;
}
</style>
</head>
<body>

<video id="video" playsinline autoplay></video>
<canvas id="canvas"></canvas>
<div id="start">TAP TO START</div>

<script>
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("start");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let lastWrist = null;
let lastIndex = null;
let lastTime = null;

startBtn.addEventListener("click", async () => {
  startBtn.style.display = "none";
  document.documentElement.requestFullscreen?.().catch(()=>{});
  startHandTracker();
});

function startHandTracker() {
  const hands = new Hands({
    locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
  });

  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
  });

  hands.onResults(results => {
    const now = performance.now();
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if(results.multiHandLandmarks && results.multiHandLandmarks.length>0){
      const hand = results.multiHandLandmarks[0];
      const wrist = {x: hand[0].x * canvas.width, y: hand[0].y * canvas.height};
      const index = {x: hand[5].x * canvas.width, y: hand[5].y * canvas.height};

      // Smooth the wrist
      if(!lastWrist){
        lastWrist = {...wrist};
        lastIndex = {...index};
      } else {
        lastWrist.x = lastWrist.x*0.7 + wrist.x*0.3;
        lastWrist.y = lastWrist.y*0.7 + wrist.y*0.3;
        lastIndex.x = lastIndex.x*0.7 + index.x*0.3;
        lastIndex.y = lastIndex.y*0.7 + index.y*0.3;
      }

      lastTime = now;
    } else if(lastWrist && lastTime){
      // Predict wrist forward if hand lost
      const dt = (now - lastTime)/16.67; // approx frames
      lastWrist.x += (lastIndex.x - lastWrist.x)*0.05*dt;
      lastWrist.y += (lastIndex.y - lastWrist.y)*0.05*dt;
    }

    if(lastWrist && lastIndex){
      // Direction vector
      let dx = lastIndex.x - lastWrist.x;
      let dy = lastIndex.y - lastWrist.y;
      const len = Math.hypot(dx,dy);
      if(len>0.001){ dx/=len; dy/=len; }

      // 3D-style line: extend far
      const lineLen = 2000;
      const endX = lastWrist.x + dx*lineLen;
      const endY = lastWrist.y + dy*lineLen;

      // Line thickness simulates depth
      ctx.lineWidth = 6; 
      ctx.strokeStyle = "lime";
      ctx.beginPath();
      ctx.moveTo(lastWrist.x,lastWrist.y);
      ctx.lineTo(endX,endY);
      ctx.stroke();

      // Big wrist circle
      ctx.beginPath();
      ctx.arc(lastWrist.x,lastWrist.y,20,0,Math.PI*2);
      ctx.fillStyle="lime";
      ctx.fill();
    }
  });

  const camera = new Camera(video,{
    facingMode:"environment",
    width:1280,
    height:720,
    onFrame: async ()=>{ await hands.send({image:video}); }
  });
  camera.start();
}
</script>

</body>
</html>

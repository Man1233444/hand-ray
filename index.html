<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Full-Screen Sniper Scope</title>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: black;
  overflow: hidden;
}

video, canvas {
  position: absolute;
  width: 100%;
  height: 100%;
  object-fit: cover;
}

#start {
  position: fixed;
  inset: 0;
  background: black;
  color: white;
  font-size: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 999;
  cursor: pointer;
}
</style>
</head>
<body>

<video id="video" playsinline autoplay></video>
<canvas id="canvas"></canvas>
<div id="start">TAP TO START</div>

<script>
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("start");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let lastWrist = null;
let lastIndex = null;

startBtn.addEventListener("click", () => {
  startBtn.style.display = "none";
  document.documentElement.requestFullscreen?.().catch(()=>{});
  startHandTracker();
});

function startHandTracker() {
  const hands = new Hands({
    locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
  });

  hands.setOptions({
    maxNumHands: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
  });

  hands.onResults(draw);

  const camera = new Camera(video, {
    facingMode: "environment",
    width: 1280,
    height: 720,
    onFrame: async () => await hands.send({ image: video })
  });

  camera.start();
}

function draw(results) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Predictive hand tracking
  if (results.multiHandLandmarks && results.multiHandLandmarks.length) {
    const hand = results.multiHandLandmarks[0];
    const wrist = { x: hand[0].x * canvas.width, y: hand[0].y * canvas.height };
    const index = { x: hand[5].x * canvas.width, y: hand[5].y * canvas.height };

    if (!lastWrist) {
      lastWrist = wrist;
      lastIndex = index;
    } else {
      lastWrist.x = lastWrist.x*0.7 + wrist.x*0.3;
      lastWrist.y = lastWrist.y*0.7 + wrist.y*0.3;
      lastIndex.x = lastIndex.x*0.7 + index.x*0.3;
      lastIndex.y = lastIndex.y*0.7 + index.y*0.3;
    }
  }

  // Direction vector
  let dx = 0, dy = -1;
  if (lastWrist && lastIndex) {
    dx = lastIndex.x - lastWrist.x;
    dy = lastIndex.y - lastWrist.y;
    const l = Math.hypot(dx, dy);
    if (l > 0.001) { dx /= l; dy /= l; }
  }

  // Draw a long green line from wrist forward
  if(lastWrist){
    const lineLen = 2000;
    const endX = lastWrist.x + dx * lineLen;
    const endY = lastWrist.y + dy * lineLen;

    ctx.strokeStyle = "lime";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(lastWrist.x, lastWrist.y);
    ctx.lineTo(endX, endY);
    ctx.stroke();

    // Wrist indicator
    ctx.beginPath();
    ctx.arc(lastWrist.x, lastWrist.y, 20, 0, Math.PI*2);
    ctx.fillStyle = "lime";
    ctx.fill();
  }

  // Draw full-screen sniper scope crosshair
  const cx = canvas.width/2;
  const cy = canvas.height/2;

  ctx.strokeStyle = "red";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(cx-30, cy);
  ctx.lineTo(cx+30, cy);
  ctx.moveTo(cx, cy-30);
  ctx.lineTo(cx, cy+30);
  ctx.stroke();

  // Optional: aim dot moves along hand direction
  const offset = 150;
  ctx.fillStyle = "lime";
  ctx.beginPath();
  ctx.arc(cx + dx*offset, cy + dy*offset, 8, 0, Math.PI*2);
  ctx.fill();
}
</script>

</body>
</html>
